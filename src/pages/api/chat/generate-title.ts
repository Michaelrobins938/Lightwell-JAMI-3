// API endpoint for AI-powered chat title generation

import { NextApiRequest, NextApiResponse } from 'next';
import { OpenAI } from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface TitleGenerationRequest {
  prompt: string;
  options: {
    style: string;
    maxLength: number;
    includeEmoji: boolean;
    language: string;
  };
  conversationId: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { prompt, options, conversationId }: TitleGenerationRequest = req.body;

    if (!prompt) {
      return res.status(400).json({ error: 'Prompt is required' });
    }

    // Check if OpenAI API key is available
    if (!process.env.OPENAI_API_KEY) {
      console.warn('OpenAI API key not found, using mock response');
      return generateMockTitle(req, res, options);
    }

    // Generate title using OpenAI
    const startTime = Date.now();

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 60,
      presence_penalty: 0.1,
      frequency_penalty: 0.1,
    });

    const processingTime = Date.now() - startTime;
    const title = completion.choices[0]?.message?.content?.trim();

    if (!title) {
      throw new Error('No title generated by AI');
    }

    // Calculate confidence based on response quality
    const confidence = calculateTitleConfidence(title, options);

    // Generate alternatives if requested
    const alternatives = await generateAlternativeTitles(prompt, options, title);

    res.status(200).json({
      success: true,
      title,
      confidence,
      alternatives,
      processingTime,
      tokenUsage: completion.usage,
      model: completion.model
    });

  } catch (error) {
    console.error('Title generation error:', error);
    
    // Fallback to mock generation if OpenAI fails
    if (error && typeof error === 'object' && 'error' in error && 
        typeof error.error === 'object' && error.error && 'code' in error.error) {
      const errorCode = (error.error as any).code;
      if (errorCode === 'insufficient_quota' || errorCode === 'rate_limit_exceeded') {
        return res.status(429).json({ error: 'Rate limit exceeded. Please try again later.' });
      }
    }

    res.status(500).json({
      success: false,
      error: 'Title generation failed',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}

// Fallback mock title generation
async function generateMockTitle(req: NextApiRequest, res: NextApiResponse, options: any) {
  const { prompt } = req.body;
  
  // Extract key information from the prompt for mock generation
  const conversationText = prompt.toLowerCase();
  let title = 'New Conversation';
  
  // Simple keyword-based title generation
  if (conversationText.includes('help') || conversationText.includes('question')) {
    title = 'Help Request';
  } else if (conversationText.includes('explain') || conversationText.includes('what is')) {
    title = 'Explanation Request';
  } else if (conversationText.includes('code') || conversationText.includes('programming')) {
    title = 'Programming Discussion';
  } else if (conversationText.includes('write') || conversationText.includes('create')) {
    title = 'Content Creation';
  } else if (conversationText.includes('analyze') || conversationText.includes('review')) {
    title = 'Analysis Request';
  } else if (conversationText.includes('plan') || conversationText.includes('strategy')) {
    title = 'Planning Session';
  } else {
    // Try to extract the first meaningful phrase
    const lines = conversationText.split('\n');
    const userLines = lines.filter((line: any) => line.startsWith('user:'));
    if (userLines.length > 0) {
      const firstUserMessage = userLines[0].replace('user:', '').trim();
      const words = firstUserMessage.split(' ').slice(0, 6);
      title = words.join(' ');
      if (title.length > options.maxLength - 3) {
        title = title.slice(0, options.maxLength - 3) + '...';
      }
    }
  }

  // Apply style modifications
  if (options.style === 'creative') {
    title = `âœ¨ ${title}`;
  } else if (options.style === 'technical') {
    title = `[${title}]`;
  }

  // Add emoji if requested
  if (options.includeEmoji) {
    const emojis = ['ğŸ’¬', 'ğŸ¤”', 'ğŸ“', 'ğŸ”', 'ğŸ’¡', 'ğŸš€'];
    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
    title = `${randomEmoji} ${title}`;
  }

  // Generate mock alternatives
  const alternatives = [
    `Discussion: ${title.replace(/^(âœ¨|ğŸ’¬|ğŸ¤”|ğŸ“|ğŸ”|ğŸ’¡|ğŸš€)\s*/, '')}`,
    `Chat about ${title.toLowerCase().replace(/^(âœ¨|ğŸ’¬|ğŸ¤”|ğŸ“|ğŸ”|ğŸ’¡|ğŸš€)\s*/, '')}`,
    `Q&A: ${title.replace(/^(âœ¨|ğŸ’¬|ğŸ¤”|ğŸ“|ğŸ”|ğŸ’¡|ğŸš€)\s*/, '')}`
  ];

  res.status(200).json({
    success: true,
    title,
    confidence: 0.6,
    alternatives,
    processingTime: 100,
    tokenUsage: {
      promptTokens: 50,
      completionTokens: 10,
      totalTokens: 60
    },
    model: 'mock-gpt-3.5-turbo'
  });
}

// Calculate confidence score based on title quality
function calculateTitleConfidence(title: string, options: any): number {
  let confidence = 0.8;

  // Reduce confidence for very short or very long titles
  if (title.length < 10) confidence -= 0.2;
  if (title.length > options.maxLength * 0.9) confidence -= 0.1;

  // Increase confidence for titles with good structure
  if (/^[A-Z]/.test(title)) confidence += 0.05;
  if (!/\b(chat|conversation|discussion)\b/i.test(title)) confidence += 0.05;

  // Clamp confidence between 0.3 and 1.0
  return Math.max(0.3, Math.min(1.0, confidence));
}

// Generate alternative title suggestions
async function generateAlternativeTitles(
  originalPrompt: string, 
  options: any, 
  originalTitle: string
): Promise<string[]> {
  try {
    // Generate alternatives with different styles
    const alternativePrompt = `${originalPrompt}

Generate 2 alternative titles that are different from "${originalTitle}":`;

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: alternativePrompt }],
      temperature: 0.9,
      max_tokens: 80,
    });

    const response = completion.choices[0]?.message?.content?.trim();
    if (response) {
      // Parse multiple titles from response
      const titles = response
        .split('\n')
        .map(line => line.replace(/^\d+\.\s*/, '').replace(/^[-*]\s*/, '').trim())
        .filter(line => line.length > 0 && line !== originalTitle)
        .slice(0, 3);

      return titles;
    }
  } catch (error) {
    console.warn('Failed to generate alternative titles:', error);
  }

  // Fallback alternatives
  return [
    `Discussion: ${originalTitle}`,
    `Chat: ${originalTitle}`,
    `Q&A Session`
  ];
}